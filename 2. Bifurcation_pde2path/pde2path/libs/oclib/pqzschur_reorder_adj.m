function [AB3,AB4,QZ3,Z1,Z2,d] = pqzschur_reorder_adj(A,B)% *: periodic Schur decomposition for adjointif nargin ~= 2; error('Two input arguments required.'); end[m,n,k] = size(A);nu=m;if ( m~=n );  error('A must n-by-n-by-k');endif ( k <= 0); error('k must be greater than zero'); end[mB,nB,kB] = size(B);if ( mB~=n || nB~=n || kB ~= k ); error('B must n-by-n-by-k'); end   % merge A and BAB = complex(zeros(n,n,2*k)); s  = zeros(2*k,1);mo=speye(n,n);for i = 1:k   AB(:,:,i*2-1) = A(:,:,i)';  s(i*2-1) = 1;   AB(:,:,i*2) = B(:,:,i)'; s(i*2) = -1;endif isreal(AB);  AB = complex(AB); end% computationsQZ = complex(zeros(n,n,2*k));[QZ2,AB2] = percomplex(2,AB,s);QZ2=reshape(QZ2,n,n,2*k);AB2=reshape(AB2,n,n,2*k);% calc eigsfor i=1:k    A(:,:,i)=AB2(:,:,2*i-1);    B(:,:,i)=AB2(:,:,2*i);endd=ones(nu,1);for i=1:nu    for z=1:k        d(i)=d(i)*A(i,i,z)/B(i,i,z);    endend% resort[~,idx]=sort(abs(d),'descend');select=zeros(nu,1);select(idx(1:nu/2))=1; % unstable at the beginningAB2=complex(AB2);QZ2=complex(QZ2);[QZ3,AB3]=percomplex(3,QZ2,AB2,s,select);QZ3=reshape(QZ3,n,n,2*k);AB3=reshape(AB3,n,n,2*k);Z1=QZ3(:,:,1)';for a=1:size(AB3,3)    for b=1:size(AB3,2)        [~,idx2]=max(abs(real(AB3(b,:,a))));        fac=imag(AB3(b,idx2,a))/real(AB3(b,idx2,a));        AB3(b,:,a)=real((1-1i*fac)*AB3(b,:,a));        [~,idx2]=max(abs(real(QZ3(b,:,a))));        fac=imag(QZ3(b,idx2,a))/real(QZ3(b,idx2,a));        QZ3(b,:,a)=(1-1i*fac)*QZ3(b,:,a);        QZ3(b,:,a)=QZ3(b,:,a)/norm(QZ3(b,:,a));    endendZ1=QZ3(:,:,1)';select(idx(n/2+1))=1; % also neutral eigenvector to the beginning[QZ4,AB4]=percomplex(3,QZ2,AB2,s,select);QZ4=reshape(QZ4,n,n,2*k);AB4=reshape(AB4,n,n,2*k);Z2=QZ4(:,:,1)';A2=zeros(size(A));B2=zeros(size(B));for i=1:k    A2(:,:,i)=AB4(:,:,2*i-1);    B2(:,:,i)=AB4(:,:,2*i);endd2=ones(nu,1);for i=1:nu    for z=1:k        d2(i)=d2(i)*A2(i,i,z)/B2(i,i,z);    endend